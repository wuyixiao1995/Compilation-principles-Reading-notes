import sys
import time
import os
import configparser
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QPushButton, QProgressBar, \
    QTextEdit, QMessageBox, QLabel, QDesktopWidget
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from PyQt5.QtGui import QFont
import concurrent.futures
import threading


class Log:
    def __init__(self):
        self.log_messages = []
        log_message = pyqtSignal(str)

    def append(self, message):
        """添加日志消息"""
        self.log_messages.append(message)

    def save(self, addr):
        """保存日志到指定地址"""
        try:
            with open(addr, 'w') as log_file:
                log_file.write('\n'.join(self.log_messages))
            return True
        except Exception as e:
            print(f"Failed to save log to {addr}: {str(e)}")
            return False


class FileParser(QThread):
    update_progress = pyqtSignal(int)
    log_message = pyqtSignal(str)

    def __init__(self, file1, file2):
        super().__init__()
        self.file1 = file1
        self.file2 = file2
        self.thread_id_to_number = {}  # 用于存储线程ID到线程号的映射关系

    def run(self):
        # 模拟解析文件的过程
        total_files = 2
        for i in range(total_files):
            time.sleep(1)  # 模拟解析文件的耗时操作
            self.log_message.emit(f'解析文件 {i + 1}/{total_files}')
            self.update_progress.emit((i + 1) * 100 // total_files)
        self.log_message.emit('解析完毕')
        # self.finished.emit()

        self.executeTasks()

    def executeTasks(self):
        max_workers = 5  # 你的线程池的最大工作线程数
        # 创建线程池并提交任务
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # 创建任务
            tasks = [(task_id + 1) for task_id in range(120)]

            # 提交任务时将任务ID传递给任务
            results = [executor.submit(self.do_task, task_id) for task_id in tasks]

            # 等待所有任务完成
            concurrent.futures.wait(results)

    def do_task(self, task_id):
        # 获取当前线程的标识符（线程ID）
        thread_id = threading.get_ident()

        # 这里定义你想要在线程池中执行的任务，包括线程号
        # 可以根据需要修改这个函数来执行具体的任务
        # time.sleep(2)  # 模拟一个任务的耗时操作
        self.log_message.emit(f'任务 {task_id} 由线程 {thread_id} 完成')


class FileParserApp(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()
        self.loadSavedAddresses()  # 加载已保存的地址
        self.log = Log()

    def initUI(self):
        self.setWindowTitle('文件解析工具')
        # 获取屏幕大小
        screen_size = QDesktopWidget().screenGeometry()
        window_width = screen_size.width() // 2  # 四分之一屏幕宽度
        window_height = screen_size.height() // 2  # 四分之一屏幕高度
        self.setGeometry((screen_size.width() - window_width) // 2, (screen_size.height() - window_height) // 2,
                         window_width, window_height)

        # 设置字体加粗
        font = QFont('等线', 10)
        font.setBold(True)
        self.setFont(font)

        layout = QVBoxLayout()

        self.file1_label = QLabel('文件1地址：', self)
        self.file1_edit = QLineEdit(self)
        self.file1_edit.setPlaceholderText('请输入文件1的地址')

        self.file2_label = QLabel('文件2地址：', self)
        self.file2_edit = QLineEdit(self)
        self.file2_edit.setPlaceholderText('请输入文件2的地址')

        parse_button = QPushButton('解析文件', self)
        parse_button.clicked.connect(self.parseFiles)
        parse_button.setStyleSheet('background-color: lightblue;')

        open_path_button = QPushButton('打开log路径', self)
        open_path_button.setFont(font)
        open_path_button.clicked.connect(sel.openPythonFolder)

        # 创建水平布局以容纳进度标签和进度条
        progress_layout = QHBoxLayout()
        self.progress_label = QLabel('进度：', self)
        self.progress_bar = QProgressBar(self)
        self.progress_bar.setFormat("%p%")
        progress_layout.addWidget(self.progress_label)
        progress_layout.addWidget(self.progress_bar)

        # 创建水平布局以容纳进度标签和进度条
        progress_layout2 = QHBoxLayout()
        progress_layout2.addWidget(parse_button)
        progress_layout2.addWidget(open_path_button)

        self.log_text = QTextEdit(self)
        self.log_text.setReadOnly(True)

        layout.addWidget(self.file1_label)
        layout.addWidget(self.file1_edit)
        layout.addWidget(self.file2_label)
        layout.addWidget(self.file2_edit)
        layout.addLayout(progress_layout2)  # 添加水平布局
        layout.addLayout(progress_layout)  # 添加水平布局
        layout.addWidget(self.log_text)

        self.setLayout(layout)

    def parseFiles(self):
        file1 = self.file1_edit.text()
        file2 = self.file2_edit.text()

        if not (os.path.exists(file1) and os.path.exists(file2)):
            QMessageBox.warning(self, '错误', '文件路径无效')
            return

        self.progress_bar.setValue(0)
        self.log_text.clear()

        self.parser_thread = FileParser(file1, file2)
        self.parser_thread.update_progress.connect(self.progress_bar.setValue)
        self.parser_thread.log_message.connect(self.handleLogMessage)
        self.parser_thread.finished.connect(self.showCompleteMessage)

        self.parser_thread.start()

        # 保存输入的地址
        self.saveAddresses(file1, file2)

    def handleLogMessage(self, message):
        # 自定义函数用于处理日志消息
        self.log_text.append(message)
        self.log.append(message)

    def showCompleteMessage(self):
        self.log.save("log.txt")
        print("----------------")
        QMessageBox.information(self, '完成', '文件解析完毕')

    def loadSavedAddresses(self):
        # 从配置文件中加载已保存的地址
        config = configparser.ConfigParser()
        config.read('addresses.ini')

        if 'Addresses' in config:
            addresses = config['Addresses']
            if 'file1' in addresses:
                self.file1_edit.setText(addresses['file1'])
            if 'file2' in addresses:
                self.file2_edit.setText(addresses['file2'])

    def saveAddresses(self, file1, file2):
        # 保存地址到配置文件
        config = configparser.ConfigParser()
        config['Addresses'] = {
            'file1': file1,
            'file2': file2
        }
        with open('addresses.ini', 'w') as configfile:
            config.write(configfile)

    def openPythonFolder(self):
        python_folder = os.path.dirname(os.path.abspath(__file__))
        os.system(f"explorer {python_folder}")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = FileParserApp()
    window.show()
    sys.exit(app.exec_())
